# A Developer's Guide to the Optimizer (SELECT version)

Query optimization is the process by which a physical operator query plan is generated from an input SQL statement. In this document, we will go through the process of optimizing a simple `SELECT` statement in NoisePage. Other queries will follow a similar format, but might have different sets of rules explored.

The example referred to in this guide is generated from the query

```sql
SELECT NO_O_ID FROM NEW_ORDER 
WHERE NO_D_ID = 4 AND NO_W_ID = 1
ORDER BY NO_O_ID ASC  
LIMIT 5;
```

run on a loaded TPCC dataset with `ScaleFactor=4`.

# 1. Traffic Cop Layer

Optimization starts after the binding process in our system's traffic cop. 

In `traffic_cop.cpp`, `TrafficCop::OptimizeBoundQuery` takes as input a:

- `const common::ManagedPointer<network::ConnectionContext> connection_ctx`: A context that stores the state of the active connection to the client
- `const common::ManagedPointer<parser::ParseResult> query`: The output statements and expressions generated by the parser

and will generate as output a:

- `std::unique_ptr<planner::AbstractPlanNode> physical_plan`: the generated physical plan for the query

This function, in turn, calls `TrafficCopUtil::Optimize` that takes in additional arguments to track the active transaction, catalog information, the internal database ID, statistics, the active cost model, and a timeout period for the optimizer, which explored further below.

# 2. Input Transformation

The first step within the optimization process is to transform the input `SQLStatement` to a set of logical expressions,`AbstractOptimizerNode logical_exprs`, in `QueryToOperatorTransformer::ConvertToOpExpression`.  In the `QueryToOperatorTransformer` class, we start by visiting the `SelectStatement` outputted by the parse process:

- If the `SELECT` statement operates upon a table, the `TableRef` is accepted as well and added to the `output_expr_` as a `LogicalGet`. Otherwise, the `LogicalGet` is initialized to operate on an invalid table (used for queries like `SELECT 1 + 1`).
- Predicates for the input expression, if they exist, are collected with an alias to each referenced column's associated table name in `std::vector<AnnotatedExpression> predicates_` and are stored in a `LogicalFilter` that is added as the parent of the existing `output_expr_`
    - [ ]  Add information for subquery transformation above
- [ ]  Add information about aggregations in `SELECT` here
- [ ]  Add information about `SelectDistinct` in `SELECT` here
- If a `LIMIT` exists in the select statement, the value of the limit and associated offset, along with any  `ORDER_BY` clauses, are stored in a `LogicalLimit` node that is added as the parent of the existing `output_expr_`

Our example query has both a `LogicalLimit` and set of `LogicalFilter`s above a `LogicalGet` in the `output_expr_`.

Following the above transformations, we create a `QueryInfo` object that keeps track of the query type. Additionally, on a `SELECT` statement, we also keep track of the output columns and sort properties in the `QueryInfo` object.

The top-level function call of the following sections is `Optimizer::BuildPlanTree`, which takes as input:

- `transaction::TransactionContext *txn`: the active transaction
- `catalog::CatalogAccessor *accessor`: the catalog accessor
- `StatsStorage *storage`: a structure to manage table statistics
- `QueryInfo query_info`: information directly relevant to active query (type, output expressions, physical properties)
- `std::unique_ptr<AbstractOptimizerNode> op_tree`: the logical expression tree generated from the transformation

and will eventually output the physical plan chosen.

# 3. Optimization

The bulk of the optimization logic occurs in this section. The optimization loop generates all transformations, . Some key related definitions follow:

- `OptimizationContext`: the structure which keeps track of required properties, costs, and the OptimizerContext for each optimization process.
- `OptimizerContext`: the structure which tracks the cost model, task pool, transaction context, statistics storage, catalog accessor, rule set, and tracked optimization contexts, and importantly the **memoized expressions for each group.**
- `Memo`: a class to track groups and group expressions that allows for duplicate detection, rewrites, access, and erase procedures.
- `GroupExpression`: a class to track a specific operator (logical or physical) in a group which tracks the transaction, group number, whether the stats have been derived, the lowest cost satisfying the required properties of an expression, and the details of the expression.
- `Group`: a class to collect group expressions representing logically equivalent expressions including logical and physical transformations.
- `LogicalExpression`: a group expression which represents a logical expression i.e. the logical operator that specifies the general behavior of a node
- `PhysicalExpression`: a group expression which represents a logical expression i.e. the physical operator that specifies the implementation details of the expression
- `Rule`: definition of a transformation from one expression to another (may be logical transformation, physical implementation, or rewrite)
- `Property`: interface to define a physical property, currently of which only sort properties exist
- `PropertySet`: interface to group together properties and also track whether each property is optional

## Setup

For each expression in the logical expression tree, a `GroupExpression` is created that initializes the `group_id_t_ group_id_` and `child_groups_`, a vector of the `group_id_t`'s of the child groups (child logical expressions), and generates an associated `Group` that initializes it's own `group_id_t id_`, `table_aliases_`, and the initial `GroupExpression` for this group in `logical_expressions_`. Effectively, each logical expression will be part of its own `Group`.

Physical properties are additionally kept track of in `PropertySet *phys_properties`, along with output expressions in `std::vector<common::ManagedPointer<parser::AbstractExpression>> output_exprs`, both of which are later passed to the `ChooseBestPlan` phase in section 4.

## Optimization Loop

In `Optimizer::OptimizeLoop`, we operate on the memoized expressions from the `group_id_t root_group_id` and with a set of `required_props`. We begin by initializing an `OptimizationContext` which stores the current `OptimizerContext` structure as well as the required physical properties. Additionally, a stack is created to manage optimization tasks in a LIFO manner. The `Optimizer`'s task stack begins with (at the top of the stack) `BottomUpRewrite` tasks, followed by `TopDownRewrite`. Following completion of this stack, a new stack then continues to perform the statistics calculations and finally, the optimizer will explore logically equivalent expressions, compute costs, and choose the optimal plan (with lowest cost) for the execution engine. A task stack runs up to the `task_execution_timeout_` setting ***IF*** a costed expression satisfying the properties is chosen, or until all the tasks in the stack have been completed otherwise. 

### Bottom Up Rewrite

The bottom up rewrite initially attempts to rewrite from the root group. For each group, the program will recursively push rewrite tasks for all sub-tree groups to be completed before re-attempting the rewrite of the current group. Upon completion of all child tasks, which is ensured by the LIFO stack ordering, and kept track of with the `has_optimized_child` flag in the `BottomUpRewrite` task, the task will attempt to check any rules defined to be in the `RuleSet` with a `RuleSetName` value matching that defined in `rule.cpp`. Rules are determined to be "valid" in `OptimizerTask::ConstructValidRules`, first checking whether the root pattern of the rule is satisfied for the group expression and the correct number of children exists (if the rule has not already been explored). 

For each valid rule, a binding iterator for the group expression is created with a call to the constructor for `GroupExprBindingIterator`. If a binding is found, the transformation from the before state of the group expression to the after state (if one exists) is applied. We expect only one output from the rewrite. If a new expression is made, we will replace the current logical expression of the group with the outputted logical expression created by the transformation rule (of base class `Rule::Transform`) in `OptimizerContext::ReplaceRewriteExpression`. If  a transformation is successfully completed, the current Rewrite task is pushed back on the stack. If a binding is not found, no such action happens. In either case, the rule is marked as explored for the current group expression, `cur_group_expr`.

This sub-section will now further explore the actions of `GroupExprBindingIterator`, as utilized above. 

The constructor for this class first repeats the valid rule checks from `OptimizerTask::ConstructValidRules` (as they may not have previously been performed on a child from the potential recursive call described below). If these checks fail, the function returns and `has_next_`, which identifies a valid binding exists on an ensuing call to `GroupExprBindingIterator::HasNext`, is never set to true. 

Otherwise, for each child group, this function creates a `GroupBindingIterator` to attempt to match with the child pattern expected by the rule, and will collect all the bindings for each child in the variable `child_bindings`. If all of the child groups can bind to the expected child patterns, the `has_next_` flag is set to true and a binding to an `OperatorNode` tracking the expression, children, and active transaction, is created. If any of the child groups do not have valid bindings, the binding attempt fails, and again, `has_next_` is never set to true.

To complete a consideration of `GroupExprBindingIterator`, `GroupExprBindingIterator::HasNext` will first check whether both `has_next_` and `first_` are set, in which case, the function may return true, as there is a next binding that has not been encountered yet. However, if only `has_next_` is set to true, there are two cases.  If all the bindings of all the children (from the last child to the first), have been tried, then there is no next binding. Otherwise, the children in the operator are replaced with the next appropriate child binding set per the positions in `children_bindings_pos_`.

Finally, the current state of `has_next_` is returned.

This sub-section will now further explore the actions of `GroupBindingIterator`, as utilized above. 

Each `GroupBindingIterator iterator`, on a call to `GroupBindingIterator::HasNext` will first check if the expected pattern is of `OpType::LEAF`, in which case `current_item_index_` must never have been incremented. Otherwise, if `current_iterator_` has already been set, we check whether there still exist bindings in the current item, and if not, increment the index and reset the variable. If `current_iterator_` had not previously been set, we attempt to find a matching pattern by recursively creating a new `GroupExprBindingIterator` for each logical expression in this child group. If no matching pattern is found for any of the logical expressions, (the boolean field `has_next_` is not set for any of the logical expressions, and thus no binding is made) the iterator will not be able to match the child pattern, reset its value to `nullptr`, and return `false` to its caller. However, if one is found, we change the `current_iterator_` to the new logical expression iterator and return.

### Top Down Rewrite

The top down rewrite phases similarly attempt to rewrite from the root group, first applying the `PREDICATE_PUSH_DOWN` rules, and then the `CLAUSE_PUSH_DOWN` rules defined in `rule.cpp` (the following process is run for each of the two rule sets). As before, rules are determined to be "valid" in `OptimizerTask::ConstructValidRules`, first checking whether the root pattern of the rule is satisfied for the group expression and the correct number of children exists (if the rule has not already been explored). 

For each valid rule, a binding iterator for the group expression is created with a call to the constructor for `GroupExprBindingIterator`  (details on `GroupExprBindingIterator` are found in the Bottom Up Rewrite section). If a binding is found, the transformation from the before state of the group expression to the after state (if one exists) is applied. We expect only one output from the rewrite. If a new expression is made, we will replace the current logical expression of the group with the outputted logical expression created by the transformation rule (of base class `Rule::Transform`) in `OptimizerContext::ReplaceRewriteExpression`. If  a transformation is successfully completed, the current Rewrite task is pushed back on the stack. If a binding is not found, no such actions happen. In either case, the rule is updated to explored for the current group expression, `cur_group_expr`.

Finally, we push new tasks for all children groups of the current group to apply the same rule set executed on this pass.

### Derive Stats

With the rewriting phases complete, we will first go through the statistics derivation process for our logical plan. We start by pushing a `DeriveStats` task for the root group onto the task stack. 

Inside each DeriveStats task, first, we create a `ChildStatsDeriver` object that is then used to create a vector of expression sets for the appropriate number of children groups (and then call `OperatorVisitor::Visit(const NODETYPE *NODENAME)`, which thus far is unimplemented). Then, for each child group, if any the required stats are empty, or the first logical expression in any child does not have stats derived, we will push the current task back onto the stack, and then push tasks to derive the stats of each child group logical expression not yet completed. 

On the final call to the current `DeriveStats` task, we calculate the stats for the group expression, and set a flag in the expression indicating the stats have been derived. The implementations of the statistics calculation process with `StatsCalculator::Visit(arg)` function vary by operator type. However, we will describe a pair of examples to follow:

We will describe a pair of such processes, taken from our running example:

- `StatsCalculator::Visit(const LogicalGet *op)` In the case the `LogicalGet` corresponds to a dummy scan, no stats will be calculated and we return immediately. Otherwise, we consider the statistics of the table in question. If no `TableStats` exist in the optimizer's context, identified by database and table id pairs, then, for each of the required columns,  default stats are initialized with a cast to a `ColumnValueExpression` from the `ExprSet` col before calling `CreateDefaultStats` on the result and returning.

    If `TableStats` does exist, then we may copy the `ColumnStats` from the existing `TableStats` object and otherwise, create default stats if the column does not exist, and store these computed results in `required_stats`, a map from the column name to the associated `ColumnStats` object. On the first instance of computing selectivity, for the predicates existing at this level, we will determine the base table statistics for each of the columns before then determining the row estimate (0 if no column stats exist, and filter-based estimations computed in `StatsCalculator::EstimateCardinalityForFilter` otherwise).

    Finally, for each column in the required columns, we add the stats for the columns into the group.

- `StatsCalculator::Visit(const LogicalLimit *op)`  this operation will first set the number of rows for the Limit's group to be the minimum of the limit and the number of rows of the child group. Then, for each of the required output columns, the stats are copied from the child group, and the number of rows determined above is set in the `ColumnStats` object as well, before being added to the current group.

### Optimize Group

After the determination of stats for the groups in our logical expression tree, we start to optimize the given groups, starting from the root. Optimizing a group attempts to choose a "best expression" for that group satisfying all required properties (i.e. a lowest cost group). In attempting to optimize a group, we first push tasks of the form `OptimizeExpression(logical_expr, context)` onto the task stack for all the logical expressions of a group, if the group has not previously been explored and can have its cost lowered . Then, for each physical expression in the group, we push an `OptimizeExpressionCostWithEnforcedProperty(physical_expr, context_)` task, which is executed in the task stack before optimizing logical expressions. Once done, this group will be fully explored as there are no cycles, and we will not revisit this group. 

Calls to `OptimizeExpression` proceed by attempting to apply rules from the `LOGICAL_TRANSFORMATION` and `PHYSICAL_IMPLEMENTATION` rulesets. As in previous section, rules are determined to be "valid" in `OptimizerTask::ConstructValidRules`, first checking whether the root pattern of the rule is satisfied for the group expression and the correct number of children exists (if the rule has not already been explored). For each valid rule `r`, a task of the form `ApplyRule(group_expr_, r.GetRule(), context_)` is pushed onto the task stack to be explored. Then, based on the rule's match pattern, if the current rule should have more non-leaf children, these child groups will be explored via an `ExploreGroup(group, context_)` with group the child group.

For a call to `ApplyRule`, a binding iterator for the group expression is created with a call to the constructor for `GroupExprBindingIterator` (details on `GroupExprBindingIterator` are found in the Bottom Up Rewrite section). If a binding is found, the transformation updates the memo to track any new group expressions created. The newly created expressions are added both to `group_expressions_` in the memo, as well as the specific group the expression is added to in `groups_` (or a new group if no group is specified). Additionally, any new logical expressions push `DeriveStats`, `ExploreExpression`, and `OptimizeExpression` tasks for the newly constructed logical expression. New physical expressions only push an `OptimizeExpressionCostWithEnforcedProperty` task onto the stack. Upon completion of this process, the rule is marked as explored.

- [ ]  Add documentation to what `ExploreExpression` does

Calls to `OptimizeExpressionCostWithEnforcedProperty` will first prune nodes that have excessive cost (currently not yet implemented) and determine a vector of output property, input property set pairs for the current expression. For each output property, input property set pair, the input properties are broken up into required and optional properties available to be satisfied by the appropriate child. If the child group is already optimized, the best expression is determined, but if not, then we re-push the `OptimizeExpressionCostWithEnforcedProperty` onto the stack to return to later, update the upper bound of the cost exploration in a new optimization context, and optimize the child group with this new context by pushing an `OptimizeGroup` task for the child onto the stack, and return from the call. Otherwise, when we do determine a best expression for all children, we update the hash table for the group expression to map the property set to the determined input properties and lowest cost, and update the current group's expression cost similarly.

- [ ]  Add explanation on meeting `PropertyEnforcer` requirements

We start by optimizing our example's root group by first optimizing the the `LogicalLimit` expression. In `OptimizeExpression` the only valid rule is the implementation rule `LogicalLimitToPhysicalLimit`, which creates a new physical operator for the limit node. As this rule expects only a leaf child, no further task is pushed for exploration. Following the rule transformation process described previously in this section, which is slightly different than the process for the rewrite rules, we generate a `PhysicalLimit` which tracks the contents of the original `LogicalLimit` and continue.

In optimizing the `Limit` expression, we first determine the input and output properties of the node, and pass down sort properties to children to optionally satisfy to allow for pruning. In particular, the `Limit` MUST satisfy any sort properties in the output from the node, but the child may also attempt to satisfy these properties ahead of time. We observe that at this point, the child group (`LogicalGet`) has not been optimized so push the `OptimizeGroup` for the child group onto the stack, repeat this process for this group (with different rules applied).

We note that the query is amenable to the rules `LogicalGetToPhysicalTableFreeScan`, `LogicalGetToPhysicalSeqScan`, and `LogicalGetToPhysicalIndexScan`, which we push `ApplyRule` tasks onto the stack for. We only consider the process for the `LogicalGetToPhysicalIndexScan` as follows. We first `Check` that the specified rule is valid, in that we check that there is an index for the table specified in the `Catalog`. Then, in the `Transform` rule, we first determine whether predicates and sorts exist in the scan and determine the index scan type to pass into the `IndexScan`. We note that the property and predicate check pass in our case, so the limit is pushed down to the `IndexScan`. 

After this (and the other) rule constructions we return to the `OptimizeExpressionCostWithEnforcedProperty` task for the groups associated with the `Get` which now determines an optimal cost, that of the `IndexScan`.

After the application completion of the above, we now return to the re-pushed `OptimizeExpressionCostWithEnforcedProperty` task for the group associated with the `Limit` and can now cost the group according to the observed cost of the child `Get` group (now determined to be an `IndexScan`.

# 4. Choosing an Output Plan

Upon completion of the optimization process, we choose the best plan by selecting the best expression for each group, starting from the root. We first derive all children plans with their own required properties, and then rebuild the overall plan from the recursive result. We note that each optimizer node is converted via the `PlanGenerator generator` into a `PlanNode`. In the case of this example, the `IndexScan` from the optimizer is converted to an `IndexScanPlanNode`, which becomes the child of the `OrderByPlanNode` generated from the `Limit` for our sort expressions. Finally, the `Limit` itself is converted to a `LimitPlanNode` with the `OrderByPlanNode` the new child of the `LimitPlanNode`.
