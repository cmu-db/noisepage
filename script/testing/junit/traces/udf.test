statement ok
-- udf.sql

statement ok
-- Integration tests for user-defined functions.

statement ok
--

statement ok
-- Currently, these tests rely on the fact that we

statement ok
-- utilize Postgres as a reference implementation

statement ok
-- because all user-defined functions are implemented

statement ok
-- in the Postgres PL/SQL dialect, PL/pgSQL.

statement ok


statement ok
-- Create a test table

statement ok
CREATE TABLE integers(x INT, y INT);

statement ok


statement ok
-- Insert some data

statement ok
INSERT INTO integers (x, y) VALUES (1, 1), (2, 2), (3, 3);

statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- return_constant()

statement ok


statement ok
CREATE FUNCTION return_constant() RETURNS INT AS $$ BEGIN RETURN 1; END $$ LANGUAGE PLPGSQL;

statement ok


query I rowsort
SELECT return_constant();
----
1


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- return_input()

statement ok


statement ok
CREATE FUNCTION return_input(x INT) RETURNS INT AS $$ BEGIN RETURN x; END $$ LANGUAGE PLPGSQL;

statement ok


query II rowsort
SELECT x, return_input(x) FROM integers;
----
1
1
2
2
3
3


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- return_sum()

statement ok


statement ok
CREATE FUNCTION return_sum(x INT, y INT) RETURNS INT AS $$ BEGIN RETURN x + y; END $$ LANGUAGE PLPGSQL;

statement ok


query III rowsort
SELECT x, y, return_sum(x, y) FROM integers;
----
1
1
2
2
2
4
3
3
6


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- return_prod()

statement ok


statement ok
CREATE FUNCTION return_product(x INT, y INT) RETURNS INT AS $$ BEGIN RETURN x * y; END $$ LANGUAGE PLPGSQL;

statement ok


query III rowsort
SELECT x, y, return_product(x, y) FROM integers;
----
1
1
1
2
2
4
3
3
9


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- integer_decl()

statement ok


statement ok
CREATE FUNCTION integer_decl() RETURNS INT AS $$ DECLARE x INT := 0; BEGIN RETURN x; END $$ LANGUAGE PLPGSQL;

statement ok


query I rowsort
SELECT integer_decl();
----
0


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- conditional()

statement ok
--

statement ok
-- TODO(Kyle): The final RETURN 0 is unreachable, but we

statement ok
-- need this temporary hack to deal with missing logic in parser

statement ok


statement ok
CREATE FUNCTION conditional(x INT) RETURNS INT AS $$ BEGIN IF x > 1 THEN RETURN 1; ELSE RETURN 2; END IF; RETURN 0; END $$ LANGUAGE PLPGSQL;

statement ok


query II rowsort
SELECT x, conditional(x) FROM integers;
----
1
2
2
1
3
1


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- proc_while()

statement ok


statement ok
CREATE FUNCTION proc_while() RETURNS INT AS $$ DECLARE x INT := 0; BEGIN WHILE x < 10 LOOP x = x + 1; END LOOP; RETURN x; END $$ LANGUAGE PLPGSQL;

statement ok


query I rowsort
SELECT proc_while();
----
10


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- proc_fori()

statement ok
--

statement ok
-- TODO(Kyle): for-loop control flow (integer variant) is not supported

statement ok


statement ok
-- CREATE FUNCTION proc_fori() RETURNS INT AS $$ -- DECLARE --   x INT := 0; -- BEGIN --   FOR i IN 1..10 LOOP --     x = x + 1; --   END LOOP; --   RETURN x; -- END -- $$ LANGUAGE PLPGSQL;

statement ok


statement ok
-- SELECT x, proc_fori() FROM integers;

statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- sql_select_single_constant()

statement ok


statement ok
CREATE FUNCTION sql_select_single_constant() RETURNS INT AS $$ DECLARE v INT; BEGIN SELECT 1 INTO v; RETURN v; END $$ LANGUAGE PLPGSQL;

statement ok


query I rowsort
SELECT sql_select_single_constant();
----
1


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- sql_select_mutliple_constants()

statement ok


statement ok
CREATE FUNCTION sql_select_mutliple_constants() RETURNS INT AS $$ DECLARE x INT; y INT; BEGIN SELECT 1, 2 INTO x, y; RETURN x + y; END $$ LANGUAGE PLPGSQL;

statement ok


query I rowsort
SELECT sql_select_mutliple_constants();
----
3


statement ok


statement ok
-- ----------------------------------------------------------------------------

statement ok
-- proc_fors()

statement ok
--

statement ok
-- TODO(Kyle): for-loop control flow (query variant) is not supported

statement ok


statement ok
-- CREATE TABLE tmp(z INT);

statement ok
-- INSERT INTO tmp(z) VALUES (0), (1);

statement ok


statement ok
-- -- Bind query result to a RECORD type

statement ok
-- CREATE FUNCTION proc_fors_rec() RETURNS INT AS $$ -- DECLARE                                           \

statement ok
--   x INT := 0; --   v RECORD; -- BEGIN --   FOR v IN (SELECT z FROM temp) LOOP --     x = x + 1; --   END LOOP; --   RETURN x; -- END -- $$ LANGUAGE PLPGSQL;

statement ok


statement ok
-- SELECT x, proc_fors_rec() FROM integers;

statement ok


statement ok
-- -- Bind query result directly to INT type

statement ok
-- CREATE FUNCTION proc_fors_var() RETURNS INT AS $$ -- DECLARE --   x INT := 0; --   v INT; -- BEGIN --   FOR v IN (SELECT z FROM tmp) LOOP --     x = x + 1; --   END LOOP; --   RETURN x; -- END -- $$ LANGUAGE PLPGSQL;

statement ok


statement ok
-- SELECT x, proc_fors_var() FROM integers;

