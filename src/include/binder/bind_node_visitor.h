#pragma once

#include <memory>
#include <string>
#include <utility>

#include "binder/binder_context.h"
#include "binder/binder_sherpa.h"
#include "binder/sql_node_visitor.h"
#include "catalog/catalog_defs.h"
#include "parser/postgresparser.h"
#include "parser/statements.h"

namespace terrier {

namespace parser {
class SQLStatement;
class CaseExpression;
class ConstantValueExpression;
class ColumnValueExpression;
class SubqueryExpression;
class StarExpression;
class OperatorExpression;
class AggregateExpression;
}  // namespace parser

namespace catalog {
class CatalogAccessor;
}  // namespace catalog

namespace binder {

/**
 * Interface to be notified of the composition of a bind node.
 */
class BindNodeVisitor : public SqlNodeVisitor {
 public:
  /**
   * Initialize the bind node visitor object with a pointer to a catalog accessor, and a default database name
   * @param catalog_accessor Pointer to a catalog accessor
   * @param db_oid oid of the connected database
   */
  BindNodeVisitor(common::ManagedPointer<catalog::CatalogAccessor> catalog_accessor, catalog::db_oid_t db_oid);

  /**
   * Perform binding on the passed in tree. Bind the relation names to oids
   * @param parse_result Result generated by the parser. A collection of statements and expressions in the query.
   */
  void BindNameToNode(common::ManagedPointer<parser::ParseResult> parse_result);

  void Visit(common::ManagedPointer<parser::SelectStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::JoinDefinition> node, common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::TableRef> node, common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::GroupByDescription> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::OrderByDescription> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::LimitDescription> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::CreateStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::CreateFunctionStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::InsertStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::DeleteStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::DropStatement> node, common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::PrepareStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::ExecuteStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::TransactionStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::UpdateStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::CopyStatement> node, common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::AnalyzeStatement> node,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::CaseExpression> expr, common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::SubqueryExpression> expr,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::ConstantValueExpression> expr,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::ColumnValueExpression> expr,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::StarExpression> expr, common::ManagedPointer<BinderSherpa> sherpa) override;
  // TODO(Ling): implement this after we add support for function expression
  void Visit(common::ManagedPointer<parser::FunctionExpression> expr,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::OperatorExpression> expr,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::AggregateExpression> expr,
             common::ManagedPointer<BinderSherpa> sherpa) override;
  void Visit(common::ManagedPointer<parser::TypeCastExpression> expr,
             common::ManagedPointer<BinderSherpa> sherpa) override;

 private:
  /** Current context of the query or subquery */
  common::ManagedPointer<BinderContext> context_ = nullptr;
  /** Catalog accessor */
  const common::ManagedPointer<catalog::CatalogAccessor> catalog_accessor_;
  const catalog::db_oid_t db_oid_;

  static void InitTableRef(const common::ManagedPointer<parser::TableRef> node) {
    if (node->table_info_ == nullptr) node->table_info_ = std::make_unique<parser::TableInfo>();
  }

  void ValidateDatabaseName(const std::string &db_name) {
    if (!(db_name.empty())) {
      const auto db_oid = catalog_accessor_->GetDatabaseOid(db_name);
      if (db_oid == catalog::INVALID_DATABASE_OID) throw BINDER_EXCEPTION("Database does not exist");
      if (db_oid != db_oid_) throw BINDER_EXCEPTION("Not connected to specified database");
    }
  }
};

}  // namespace binder
}  // namespace terrier
