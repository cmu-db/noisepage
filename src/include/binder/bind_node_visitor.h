#pragma once

#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "binder/binder_context.h"
#include "binder/binder_sherpa.h"
#include "binder/sql_node_visitor.h"
#include "catalog/catalog_defs.h"
#include "parser/postgresparser.h"
#include "parser/statements.h"

namespace terrier {

namespace parser {
class SQLStatement;
class AggregateExpression;
class CaseExpression;
class ConstantValueExpression;
class ColumnValueExpression;
class OperatorExpression;
class SubqueryExpression;
class StarExpression;
}  // namespace parser

namespace catalog {
class CatalogAccessor;
}  // namespace catalog

namespace binder {

class BinderSherpa;

/**
 * Interface to be notified of the composition of a bind node.
 */
class BindNodeVisitor : public SqlNodeVisitor {
 public:
  /**
   * Initialize the bind node visitor object with a pointer to a catalog accessor, and a default database name
   * @param catalog_accessor Pointer to a catalog accessor
   * @param db_oid oid of the connected database
   */
  BindNodeVisitor(common::ManagedPointer<catalog::CatalogAccessor> catalog_accessor, catalog::db_oid_t db_oid);

  /**
   * Perform binding on the passed in tree. Bind the relation names to oids
   * @param parse_result Result generated by the parser. A collection of statements and expressions in the query
   * @param parameters parameters for the query being bound, can be nullptr if there are no parameters
   */
  void BindNameToNode(common::ManagedPointer<parser::ParseResult> parse_result,
                      common::ManagedPointer<std::vector<type::TransientValue>> parameters);

  void Visit(common::ManagedPointer<parser::AnalyzeStatement> node) override;
  void Visit(common::ManagedPointer<parser::CopyStatement> node) override;
  void Visit(common::ManagedPointer<parser::CreateFunctionStatement> node) override;
  void Visit(common::ManagedPointer<parser::CreateStatement> node) override;
  void Visit(common::ManagedPointer<parser::DeleteStatement> node) override;
  void Visit(common::ManagedPointer<parser::DropStatement> node) override;
  void Visit(common::ManagedPointer<parser::ExecuteStatement> node) override;
  void Visit(common::ManagedPointer<parser::ExplainStatement> node) override;
  void Visit(common::ManagedPointer<parser::InsertStatement> node) override;
  void Visit(common::ManagedPointer<parser::PrepareStatement> node) override;
  void Visit(common::ManagedPointer<parser::SelectStatement> node) override;
  void Visit(common::ManagedPointer<parser::TransactionStatement> node) override;
  void Visit(common::ManagedPointer<parser::UpdateStatement> node) override;
  void Visit(common::ManagedPointer<parser::VariableSetStatement> node) override;

  void Visit(common::ManagedPointer<parser::AggregateExpression> expr) override;
  void Visit(common::ManagedPointer<parser::CaseExpression> expr) override;
  void Visit(common::ManagedPointer<parser::ColumnValueExpression> expr) override;
  void Visit(common::ManagedPointer<parser::ComparisonExpression> expr) override;
  void Visit(common::ManagedPointer<parser::ConjunctionExpression> expr) override;
  void Visit(common::ManagedPointer<parser::ConstantValueExpression> expr) override;
  void Visit(common::ManagedPointer<parser::DefaultValueExpression> expr) override;
  void Visit(common::ManagedPointer<parser::DerivedValueExpression> expr) override;
  void Visit(common::ManagedPointer<parser::FunctionExpression> expr) override;
  void Visit(common::ManagedPointer<parser::OperatorExpression> expr) override;
  void Visit(common::ManagedPointer<parser::ParameterValueExpression> expr) override;
  void Visit(common::ManagedPointer<parser::StarExpression> expr) override;
  void Visit(common::ManagedPointer<parser::SubqueryExpression> expr) override;
  void Visit(common::ManagedPointer<parser::TypeCastExpression> expr) override;

  void Visit(common::ManagedPointer<parser::GroupByDescription> node) override;
  void Visit(common::ManagedPointer<parser::JoinDefinition> node) override;
  void Visit(common::ManagedPointer<parser::LimitDescription> node) override;
  void Visit(common::ManagedPointer<parser::OrderByDescription> node) override;
  void Visit(common::ManagedPointer<parser::TableRef> node) override;

 private:
  /** BinderSherpa which stores metadata (e.g. type information) across Visit calls. **/
  std::unique_ptr<BinderSherpa> sherpa_ = nullptr;
  /** Current context of the query or subquery */
  common::ManagedPointer<BinderContext> context_ = nullptr;

  /** Catalog accessor */
  const common::ManagedPointer<catalog::CatalogAccessor> catalog_accessor_;
  const catalog::db_oid_t db_oid_;

  static void InitTableRef(const common::ManagedPointer<parser::TableRef> node) {
    if (node->table_info_ == nullptr) node->table_info_ = std::make_unique<parser::TableInfo>();
  }

  void ValidateDatabaseName(const std::string &db_name) {
    if (!(db_name.empty())) {
      const auto db_oid = catalog_accessor_->GetDatabaseOid(db_name);
      if (db_oid == catalog::INVALID_DATABASE_OID) throw BINDER_EXCEPTION("Database does not exist");
      if (db_oid != db_oid_) throw BINDER_EXCEPTION("Not connected to specified database");
    }
  }
};

}  // namespace binder
}  // namespace terrier
