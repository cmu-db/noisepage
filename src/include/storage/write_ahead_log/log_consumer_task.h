#pragma once

#include <condition_variable>  // NOLINT
#include <utility>
#include <vector>

#include "common/container/concurrent_blocking_queue.h"
#include "common/container/concurrent_queue.h"
#include "common/dedicated_thread_task.h"
#include "storage/storage_defs.h"
#include "storage/write_ahead_log/log_io.h"

namespace terrier::storage {

/**
 * Base log consumer task. A log consumer consumes logs generated by the log serializer task.
 */
  class LogConsumerTask : public common::DedicatedThreadTask {
  protected:
    /**
     * Constructs a new LogConsumerTask
     * @param persist_interval Interval time for when to persist log file
     * @param persist_threshold threshold of data written since the last persist to trigger another persist
     * @param buffers pointer to list of all buffers used by log manager, used to persist log file
     * @param empty_buffer_queue pointer to queue to push empty buffers to
     * @param filled_buffer_queue pointer to queue to pop filled buffers from
     */
    explicit LogConsumerTask(common::ConcurrentBlockingQueue<BufferedLogWriter *> *empty_buffer_queue, common::ConcurrentQueue<storage::SerializedLogs> *filled_buffer_queue)
        : run_task_(false),
          empty_buffer_queue_(empty_buffer_queue),
          filled_buffer_queue_(filled_buffer_queue) {}

    friend class LogManager;
    // Flag to signal task to run or stop
    bool run_task_;
    // The queue containing empty buffers. Task will enqueue a buffer into this queue when it has flushed its logs
    common::ConcurrentBlockingQueue<BufferedLogWriter *> *empty_buffer_queue_;
    // The queue containing filled buffers. Task should dequeue filled buffers from this queue to flush
    common::ConcurrentQueue<SerializedLogs> *filled_buffer_queue_;
  };
}  // namespace terrier::storage
